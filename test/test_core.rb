# -*- coding: utf-8 -*-

require 'japanize/core'

要求 'japanize/test_unit'

部(日本語化) {
  部(:試験) {
    組(:核となる仕組みの試験, 原型: 試験単位::試験事例) {
      試験('操作の範囲で日本語名称を確認') {
        等しいことを確認(self,                自分)
        等しいことを確認(Japanize::TOP_LEVEL, 最上位)

        等しいことを確認(Japanize, 日本語化)
        等しいことを確認(Kernel,   核)
        等しいことを確認(Module,   部)
        等しいことを確認(Class,    組)
        等しいことを確認(Object,   物)
        等しいことを確認(Symbol,   記号)
        等しいことを確認(String,   文字列)

        等しいことを確認(Test::Unit, 試験単位)
        確認(試験単位::試験事例 < Test::Unit::TestCase)
      }

      資料('自分'   => [ self,                自分 ],
           '最上位' => [ Japanize::TOP_LEVEL, 最上位 ],

           '日本語化' => [ Japanize, 日本語化 ],
           '核'       => [ Kernel,   核 ],
           '部'       => [ Module,   部 ],
           '組'       => [ Class,    組 ],
           '物'       => [ Object,   物 ],
           '記号'     => [ Symbol,   記号 ],
           '文字列'   => [ String,   文字列 ],

           '試験単位' => [ Test::Unit, 試験単位 ])
      試験('部の範囲で日本語名称を確認') {|資料|
        期待値, 日本語化した値 = 資料
        等しいことを確認(期待値, 日本語化した値)
      }

      試験('日本語名称の絶対パスを確認') {
        等しいことを確認(Japanize, ::JA::日本語化)
        等しいことを確認(Kernel,   ::JA::核)
        等しいことを確認(Module,   ::JA::部)
        等しいことを確認(Class,    ::JA::組)
        等しいことを確認(Object,   ::JA::物)
        等しいことを確認(Symbol,   ::JA::記号)
        等しいことを確認(String,   ::JA::文字列)

        等しいことを確認(Test::Unit, ::JA::試験単位)
        確認(::JA::試験単位::試験事例 < Test::Unit::TestCase)
      }

      試験('日本語の定数を確認') {
        ある組 = 組.new

        ある組.日本語の定数(:甲, 'ア')
        等しいことを確認('ア', ある組::甲)

        ある組.日本語の定数(:乙) { 'イ' }
        等しいことを確認('イ', ある組::乙)

        例外が発生することを確認(ArgumentError) {
          ある組.日本語の定数(:丙)
        }

        例外が発生することを確認(ArgumentError) {
          ある組.日本語の定数(:丙, 'エ') { 'オ' }
        }

        例外が発生することを確認(ArgumentError) {
          ある組.日本語の定数(:丙, 'エ', 'オ')
        }

        例外が発生することを確認(ArgumentError) {
          ある組.日本語の定数(:丙) {|*引数| 'オ' }
        }
      }

      試験('部や組の定義の戻り値を確認') {
        呼び出し履歴 = []
        固有の値 = 物.new

        ある物 = 物.new
        等しいことを確認(固有の値,
                         ある物.特異組{
                           呼び出し履歴 << :特異組の定義
                           固有の値
                         })
        等しいことを確認([ :特異組の定義 ], 呼び出し履歴)

        ある部 = 部.new
        等しいことを確認(固有の値,
                         部(ある部) {
                           呼び出し履歴 << :部の定義
                           固有の値
                         })
        等しいことを確認([ :特異組の定義, :部の定義 ], 呼び出し履歴)

        ある組 = 組.new
        等しいことを確認(固有の値,
                         組(ある組) {
                           呼び出し履歴 << :組の定義
                           固有の値
                         })
        等しいことを確認([ :特異組の定義, :部の定義, :組の定義 ], 呼び出し履歴)
      }

      資料('部ではない'                       => [ 最上位,   物 ],
           '最上位の定義済みの日本語の定数'   => [ 最上位,   :物 ],
           '日本語化の定義済みの日本語の定数' => [ 日本語化, :物 ],
           '定義済みの日本語の定数'           => [ 試験単位, :試験事例 ])
      試験('部の定義の型が合わないため失敗することを確認') {|資料|
        名前空間, ある部 = 資料

        例外が発生することを確認(TypeError) {
          名前空間.instance_eval{
            部(ある部) {}
          }
        }
      }

      資料('組ではない'                       => [ 最上位,   日本語化 ],
           '原型が組ではない'                 => [ 最上位,   :物,       { 原型: 日本語化 } ],
           '最上位の定義済みの日本語の定数'   => [ 最上位,   :日本語化 ],
           '最上位の組の原型が合わない'       => [ 最上位,   :文字列,   { 原型: 記号 } ],
           '日本語化の定義済みの日本語の定数' => [ 日本語化, :日本語化 ],
           '日本語化の組の原型が合わない'     => [ 日本語化, :文字列,   { 原型: 記号 } ],
           '定義済みの日本語の定数'           => [ 試験単位, :確認手段 ],
           '組の原型が合わない'               => [ 試験単位, :試験事例, { 原型: 物 } ])
      試験('組の定義の型が合わないため失敗することを確認') {|資料|
        名前空間, ある組, 名前付き引数 = 資料
        名前付き引数 ||= {}

        例外が発生することを確認(TypeError) {
          名前空間.instance_eval{
            組(ある組, **名前付き引数) {}
          }
        }
      }

      試験('バッククォート記法で操作を定義する確認') {
        ある組 = 組.new
        ある物 = ある組.new

        応答しないことを確認(ある物, :甲)

        組(ある組) {
          `定義 甲
             :いろはにほへと
          `
        }

        応答することを確認(ある物, :甲)
        等しいことを確認(:いろはにほへと, ある物.甲)
      }

      試験('バッククォート記法で操作の定義に失敗する確認') {
        ある組 = 組.new
        発生した例外 = 例外が発生することを確認(SyntaxError) {
          組(ある組) {
            `定義 1
            `
          }
        }
        含まれることを確認(発生した例外.message, "#{__FILE__}:#{__LINE__ - 4}")
      }

      試験('バッククォート記法で引数を転送する略記法を確認') {
        ある組 = 組.new
        組(ある組) {
          定義(:甲) {|*引数| 引数 }

          `定義 乙(...)
             甲(...)
          `
        }

        ある物 = ある組.new
        等しいことを確認([ 1, :イ, 'ロ' ], ある物.乙(1, :イ, 'ロ'))
      }

      試験('バッククォート記法で末尾の引数を転送する略記法を確認') {
        ある組 = 組.new
        組(ある組) {
          定義(:甲) {|名前, *引数| [ 名前, 引数 ] }

          `定義 乙(名前, [...])
             甲(名前, [...])
          `
        }

        ある物 = ある組.new
        等しいことを確認([ :丙, [ 1, :イ, 'ロ' ] ], ある物.乙(:丙, 1, :イ, 'ロ'))
      }
    }
  }
}

# Local Variables:
# mode: Ruby
# indent-tabs-mode: nil
# End:
